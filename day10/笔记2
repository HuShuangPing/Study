本文链接：
   线程，协程，进程：  
        http://www.cnblogs.com/alex3714/articles/5230609.html
    
线程 内存共享
线程同时修改同一份数据时必须加锁，mutex互斥锁
递归锁

def run(n):
  print('run thread...')




for i in range(10):
    t = threading.Thread(target=run, args=(n,))
    t.setDaemon(True)
    t.start()


print 'master is done....'

守护线程(slave) 服务与非守护线程(master)


进程 至少包含一个线程


queue
   解耦，使程序直接实现松耦合，
   提高处理效率 ，

   FIFO = first in first out
   LIFO = last in first out



Python中多进程运行时利用CPU上下文切换
io 操作不占用cpu
计算占用cpu , 如：1+1
python多线程 不适合cpu密集操作型的任务，适合io操作密集型的任务


multiprocess  多线程

进程间通信需要一个中介
1.Queue  \ Pipe 只是实现进程间数据的传递
2.Manager 实现了进程间数据的共享，即多个进程可以修改同一份数据

协程:拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈报错到其他地方，再切回来的时候恢复寄存器和栈
所以协程能保留上衣调用时状态（即所有局部状态的一个特定组合）每次过程重入是，进入上次调用的状态
1.无需线程上文切换的开销
2.无需原子操作锁定及同步的开销
3.方便切换控制流，简化变成模型
4.高并发+高扩展性+低成本：一个CPU支持上万个协程都不是问题，所以很适合高并发处理
协程是在单线程中实现的，单线程是串行的，对数据进行修改时，无需加锁

无法利用多核资源，协程的本质是个单线程，不能同时将单个CPU的多核用
协程需要和进程配合才能运行在多核CPU上
进行阻塞操作（如IO时）会阻塞掉整个程序

在单线程下实现并发，遇到io操作就切换
Greenlet---是已经封装好的协程



<h2>论事件驱动与异步IO</h2>
  <h3>(1)大多数网络服务器采用的方式：</h3>
     每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求
  <h3>(2)事件驱动模型大体思路如下：</h3>
    1. 有一个事件（消息）队列；
    2. 鼠标按下时，往这个队列中增加一个点击事件（消息）；
    3. 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；
    4. 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；
    特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。回调函数执行什么可以自己定义
<h3>另外两种常见的编程范式是（单线程）同步以及多线程编程。</h3>
![](https://i.imgur.com/9RSWi1N.png)


<h2>I/O 多路复用</h2>

  <h3>1.基本概念</h3>
     （1）用户空间与内核空间
         现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。
         操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限.
         为了保证用户进程不能直接操作内核（kernel），保证内核的安全，
         操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
         针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），
         供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。
    （2）进程切换
    （3）进程阻塞
         正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，
         则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。
         可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。
         当进程进入阻塞状态，是不占用CPU资源的。
    （4）文件描述符id
        实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。
        当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
        在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。
        但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
    (5)缓存 I/O
       存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。
       在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，
       也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
        缓存 I/O 的缺点：
         数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，
         这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。
  <h3>2.I/O模式</h3>
    对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，
    然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
    所以说，当一个read操作发生时，它会经历两个阶段：
        1. 等待数据准备 (Waiting for the data to be ready)
        2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

    正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。
    - 阻塞 I/O（blocking IO）
    - 非阻塞 I/O（nonblocking IO）
    - I/O 多路复用（ IO multiplexing）
    - 信号驱动 I/O（ signal driven IO）
    - 异步 I/O（asynchronous IO）
   
  <h4>（1） 阻塞 I/O（blocking IO）</h4>
![](https://i.imgur.com/2bA8O1Z.png)

* 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。
* 当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，
* 然后kernel返回结果，用户进程才解除block的状态，重新运行起来。
>blocking IO的特点就是在IO执行的两个阶段都被block了.一个是等待进程，一个是拷贝数据。

 <h4>(2)非阻塞 I/O（nonblocking IO）</h4>
![](https://i.imgur.com/ue5Pzs2.png)

* 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。
* 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。
* 用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。
* 一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。
>但copy数据仍然是阻塞的

>nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。

<h3>（3）I/O 多路复用（ IO multiplexing）</h3>
IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO（事件驱动）。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

![](https://i.imgur.com/dhPWpN6.png)

* 当用户进程调用了select，那么整个进程会被block，
* 而同时，kernel会“监视”所有select负责的 socket，当任何一个socket中的数据准备好了，select就会返回。
* 这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

<h3>（4）异步I/O</h3>
![](https://i.imgur.com/Ry80IPj.png)

* 用户进程发起read操作之后，立刻就可以开始去做其它的事。
* 而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。
* 然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存
* 当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

>之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous(同步) IO。
>同步I/O需要实现从内核态转变为用户态

<h4 style=color:red>各个IO Model的比较如图所示</h4>
![](https://i.imgur.com/34x6aRn.png)

[http://www.cnblogs.com/alex3714/p/4372426.html](http://www.cnblogs.com/alex3714/p/4372426.html "Select\Poll\Epoll异步IO　")
